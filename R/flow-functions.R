# wrappers around R6Flow following standard R functionality


# !diagnostics suppress=., 


make_fn_key <- function(fn, fn_id, flow_options) {
    
    # unique fn_key = hash of fn's defined arguments, body, id and options
    fn_formals <- formals(args(fn))
    arg_chr <- paste(
        paste(names(fn_formals), as.character(fn_formals), sep = "="),
        collapse = ", "
    )
    body_chr <- as.character(body(fn))
    fo_chr <- format(discard_at(flow_options, "eddy"))
    
    eddy <- flow_options$eddy
    if (is.null(fn_id)) fn_id <- 1L
    fn_key <- eddy$digest(c(arg_chr, body_chr, as.character(fn_id), fo_chr))
    
    fn_key
}


#' Explicit cache of a function.
#' 
#' @param fn Function to be cached, ideally a pure function.
#' @param fn_id Optional id to uniquely identify the function. By default,
#'   rflow functions reuse the cache if the same function is given. The id 
#'   allows the user to suppress console messages and to
#'   indicate whether to reuse the old cache or create a new one.
#' @param flow_options List of options created using \code{get_flow_options}.
#' 
#' @return The cached version of the function.
#' 
#' @export
flow_fn <- function(fn,
                    fn_id = NULL,
                    flow_options = get_flow_options()) {
    
    stopifnot(is.function(fn))
    if (any(grepl("\\.Primitive", format(fn)))) {
        rlang::abort("Primitive functions not supported.")
    }
    stopifnot(
        is.null(fn_id) || !rlang::is_na(fn_id) && (
        rlang::is_string(fn_id) || rlang::is_scalar_integerish(fn_id))
    )
    if (rlang::is_scalar_integerish(fn_id)) fn_id <- as.integer(fn_id)
    
    # when generated by get_flow_options(), flow_options are valid
    if (!is.null(flow_options$eval_arg_fn)) {
        fn_formals <- formals(args(fn))
        eval_arg_fn_formals <- formals(args(flow_options$eval_arg_fn))
        stopifnot(identical(fn_formals, eval_arg_fn_formals))
    }
    eddy <- flow_options$eddy
    
    # best place to capture the name of the function
    # fn_name (the binding) is irrelevant (it's the args and body that matter)
    # but it may be useful for debugging
    match_call <- match.call()
    if (is.symbol(match_call$fn)) {
        fn_name <- as.character(match_call$fn)
    } else {
        rlang::abort("Anonymous functions not supported.")
    }
    
    fn_key <- make_fn_key(fn, fn_id, flow_options)
    fn_names <- purrr::map_chr(eddy$flow_lst, "fn_name")
    if (fn_name %in% fn_names) {
        if (eddy$has_flow(fn_key)) {
            # the R6Flow obj exists ==> re-use it; message if no fn_id
            if (is.null(fn_id)) {
                rlang::inform(paste("Reusing cache for function", fn_name))
            }
            flow <- eddy$get_flow(fn_key)
        } else {
            # obj does not exist but same fn_name ==> new; message if no fn_id
            if (is.null(fn_id)) {
                rlang::inform(paste(
                    "Function", fn_name, "exists with different options,",
                    "creating a new cache."))
                fn_ids <- eddy$flow_lst %>%
                    purrr::keep(~ .$fn_name == fn_name) %>%
                    purrr::keep(~ rlang::is_integerish(.$fn_id)) %>%
                    purrr::map_int("fn_id")
                if (length(fn_ids) > 0L) {
                    fn_id <- as.integer(max(fn_ids) + 1)
                } else {
                    fn_id <- 1L
                }
                fn_key <- make_fn_key(fn, fn_id, flow_options)
            }
            flow <- R6Flow$new(
                fn = fn,
                fn_key = fn_key,
                fn_name = fn_name,
                fn_id = fn_id %||% 1L,
                flow_options = flow_options
            )
        }
    } else {
        if (eddy$has_flow(fn_key)) {
            rlang::inform(paste(
                "A cache for a function with the same signature but a", 
                "different name already exists, creating a new cache."))
        }
        flow <- R6Flow$new(
            fn = fn,
            fn_key = fn_key,
            fn_name = fn_name,
            fn_id = fn_id %||% 1L,
            flow_options = flow_options
        )
    }
    
    flow$rf_fn
}


#' Implicit cache of a function and processing of the given call.
#' 
#' @param fn_call Function call to be processed.
#' @param fn_id Optional id to uniquely identify the function. By default,
#'   rflow functions reuse the cache if the same function is given. The id 
#'   allows the user to suppress console messages and to
#'   indicate whether to reuse the old cache or create a new one.
#' @param flow_options List of options created using \code{get_flow_options}.
#' 
#' @return The flow object.
#' 
#' @export
flow <- function(fn_call, 
                 fn_id = NULL,
                 flow_options = get_flow_options()) {
    
    # fn_call will be replaced by its original call
    # this is to avoid triggering evaluation of fn_call
    fn_call <- parse_call()
    fn <- eval(fn_call[[1L]])
    stopifnot(is.function(fn))
    stopifnot(
        is.null(fn_id) || !rlang::is_na(fn_id) && (
        rlang::is_string(fn_id) || rlang::is_scalar_integerish(fn_id))
    )
    if (rlang::is_scalar_integerish(fn_id)) fn_id <- as.integer(fn_id)
    
    # when generated by get_flow_options(), flow_options are valid
    if (!is.null(flow_options$eval_arg_fn)) {
        fn_formals <- formals(args(fn))
        eval_arg_fn_formals <- formals(args(flow_options$eval_arg_fn))
        stopifnot(identical(fn_formals, eval_arg_fn_formals))
    }
    eddy <- flow_options$eddy
    
    if (is.symbol(fn_call[[1L]])) {
        fn_name <- as.character(fn_call[[1L]])
    } else {
        rlang::abort("Anonymous functions not supported.")
    }
    
    fn_key <- make_fn_key(fn, fn_id, flow_options)
    fn_names <- purrr::map_chr(eddy$flow_lst, "fn_name")
    if (fn_name %in% fn_names) {
        if (eddy$has_flow(fn_key)) {
            # the R6Flow obj exists ==> re-use it; message if no fn_id
            if (is.null(fn_id)) {
                rlang::inform(paste("Reusing cache for function", fn_name))
            }
            flow <- eddy$get_flow(fn_key)
        } else {
            # obj does not exist but same fn_name ==> new; message if no fn_id
            if (is.null(fn_id)) {
                rlang::inform(paste(
                    "Function", fn_name, "exists with different options,",
                    "creating a new cache."))
                fn_ids <- eddy$flow_lst %>%
                    purrr::keep(~ .$fn_name == fn_name) %>%
                    purrr::keep(~ rlang::is_integerish(.$fn_id)) %>%
                    purrr::map_int("fn_id")
                if (length(fn_ids) > 0L) {
                    fn_id <- as.integer(max(fn_ids) + 1)
                } else {
                    fn_id <- 1L
                }
                fn_key <- make_fn_key(fn, fn_id, flow_options)
            }
            flow <- R6Flow$new(
                fn = fn,
                fn_key = fn_key,
                fn_name = fn_name,
                fn_id = fn_id %||% 1L,
                flow_options = flow_options
            )
        }
    } else {
        if (eddy$has_flow(fn_key)) {
            rlang::inform(paste(
                "A cache for a function with the same signature but different",
                "name already exists, creating a new cache."))
        }
        flow <- R6Flow$new(
            fn = fn,
            fn_key = fn_key,
            fn_name = fn_name,
            fn_id = fn_id %||% 1L,
            flow_options = flow_options
        )
    }
    
    # unlike make_rf, we have a fn call to eval (in the parent.frame!)
    fn_call[[1L]] <- flow$rf_fn
    res <- eval(fn_call, envir = parent.frame())
    
    res
}


#' @importFrom dplyr collect
#' @name collect
#' @rdname collect.R6Flow
#' @export
NULL


#' Get the data from an \code{R6Flow} or an \code{Element} object.
#' 
#' @param x An flow object, e.g. as returned by \code{\link{flow}}.
#' @param ... Element of the output data to be selected. If present, it must
#'   be named \code{name}. otherwise the first item of the \code{...} list
#'   will be used. The default is \code{name = NULL}, which returns all the
#'   data.
#' 
#' @return Data associated with the output of the function.
#' 
#' @method collect R6Flow
#' @export
collect.R6Flow <- function(x, ...) {
    
    arg_lst <- list(...)
    arg_name <- if ("name" %in% names(arg_lst) || length(arg_lst) == 0L) {
        # NULL if no arguments present
        arg_lst$name
    } else {
        # there is at least one argument, not `name`; assume it is `name`
        arg_lst[[1L]]
    }
    x$collect(name = arg_name)
}


#' @rdname collect.R6Flow
#' 
#' @method collect Element
#' @export
collect.Element <- function(x, ...) {
    
    if (length(list(...)) > 0L) warning("all other arguments ignored")
    
    x$self$collect(name = x$elem_name)
}


#' Extract an element from an \code{R6Flow} object.
#' 
#' @param flow An flow object, e.g. as returned by \code{\link{flow}}.
#' @param name Element of the output data to be selected. The default is 
#'   \code{name = NULL}, which returns the element version of the \code{R6Flow} 
#'   input object.
#' 
#' @return An object with class \code{Element}.
#' 
#' @export
element <- function(flow, name = NULL) {
    
    stopifnot(inherits(flow, "R6Flow"))
    
    flow$get_element(name = name)
}


#' @rdname element
#' 
#' @export
`[.R6Flow` <- function(flow, name) {
    
    if (missing(name)) {
        flow$get_element()
    } else {
        flow$get_element(name = name)
    }
}


#' Does the flow have a "current" state? 
#' 
#' If there is no current state, e.g. right after \code{\link{flow_fn}},
#'   the flow is "not flowing", it is preventing downstream flows
#'   from being computed.
#' 
#' @param flow An flow object, e.g. as returned by \code{\link{flow}}.
#' 
#' @return A logical value, whether the current state is valid.
#' 
#' @export
is_current <- function(flow) {
    
    stopifnot(inherits(flow, "R6Flow"))
    
    flow$is_current
}


#' Is the current state valid (stored in the cache)?
#' 
#' @param flow An flow object, e.g. as returned by \code{\link{flow}}.
#' @param state An flow state. Only the \code{current} state is 
#'   accepted for now.
#' 
#' @return A logical value, whether the value can be obtained without
#'   triggering computation.
#' 
#' @export
is_valid <- function(flow, state = "current") {
    
    stopifnot(inherits(flow, "R6Flow"))
    stopifnot(identical(state, "current"))
    
    flow$is_valid
}


#' Forgets the computation for the current state.
#' 
#' @param flow An flow object, e.g. as returned by \code{\link{flow}}.
#' @param state An flow state. Only the \code{current} state is 
#'   accepted for now.
#' 
#' @return A logical value, whether the deletion was successful.
#' 
#' @export
forget <- function(flow, state = "current") {
    
    stopifnot(inherits(flow, "R6Flow"))
    stopifnot(identical(state, "current"))
    
    flow$require_good_index()
    flow$forget_state(flow$state_index)
    
    flow
}
